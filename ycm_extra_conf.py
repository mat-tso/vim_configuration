import os
import ycm_core

"""
Custom configuration for ycm
Only supports Compilation Database
    see http://clang.llvm.org/docs/JSONCompilationDatabase.html

CompilationDatabase format is
[
  {
    "directory": "/home/user/llvm/build",
    "command"  : "/usr/bin/clang++ -Irelative -DSOMEDEF=\"somevalue\" -c -o file.o file.cc",
    "file"     : "file.cc"
  },
    ...
]
It can be generated by cmake using the CMAKE_EXPORT_COMPILE_COMMANDS option

This config script uses the closest .compilation_commands.json in
the file ancestor folders.
ie. for the filepath /a/b/c/d/file
    it will test if /a/b/c/d/.compilation_commands.json exists and use it if so.
    or if /a/b/c/.compilation_commands.json exists and use it,
    ...

"""

defaultFlags = [
        '-Wall',
        '-Wextra',
        '-Werror',
    ]

SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c', '.m', '.mm']

def isHeaderFile(filepath):
    extension = os.path.splitext(filepath)[1]
    return extension in ['.h', '.hxx', '.hpp', '.hh']

def findClosestDatabase(filepath):
    """Find first matching filename/.../.compilationCommands.json"""
    folder = os.path.dirname(filepath)
    rootTested = False

    while (rootTested):
        maybeFile = folder + "/.compilation_commands.json"
        if os.path.exists(maybeFile):
            return maybeFile
        rootTested = (folder == "/")
        folder = os.path.dirname(folder)

    raise OSError()


class ParseError (Exception):
    "Exception raised when ycm could not parse a database."
    pass

def getCompilationInfoForFile(filepath, database):
    """
    The compilation_commands.json file generated by CMake does not have entries
    for header files. So we do our best by asking the db for flags for a
    corresponding source file, if any. If one exists, the flags for that file
    should be good enough.
    """
    if not IsHeaderFile(filepath):
      return database.GetCompilationInfoForFile(filepath)

    basename = os.path.splitext(filepath)[0]
    dirname = os.path.dirname(filepath)
    for extension in SOURCE_EXTENSIONS:
        for path in [".", "..", "../src"]:
            replacementFile = os.path.join([dirname, path, basename + extension])
            if os.path.exists(replacementFile):
                compilationInfo = database.GetCompilationInfoForFile(replacementFile)
                if compilationInfo.compiler_flags_:
                    return compilationInfo

    raise LookupError()


def makeRelativePathsInFlagsAbsolute(flags, workingDirectory):
    newFlags = []
    nextIsPath = False
    pathFlags = ['-isystem', '-I', '-iquote', '--sysroot=']

    for flag in flags:
        newFlag = flag

        if nextIsPath:
            nextIsPath = False
            if not flag.startswith('/'):
                newFlag = os.path.join(workingDirectory, flag)

        for pathFlag in pathFlags:
            if flag == pathFlag:
                nextIsPath = True
                break

            if flag.startswith(pathFlag):
                path = flag[len(pathFlag):]
                newFlag = pathFlag + os.path.join(workingDirectory, path)
                break

        if newFlag:
            newFlags.append(newFlag)

    return newFlags

def directoryOfThisScript():
    return os.path.dirname(os.path.abspath(__file__))

def findFlagsInDatabase(filepath):

    databasePath = findClosestDatabase(filepath)

    database = ycm_core.CompilationDatabase(compilation_database_folder)
    if not database:
        raise ParseError()

    compilationInfo = getCompilationInfoForFile(filepath, database)

    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a "list-like" StringVec object
    flags = list(compilationInfo.compiler_flags_)
    relativeTo = compilationInfo.compiler_working_dir_

    return makeRelativePathsInFlagsAbsolute(flags, relativeTo)

def FlagsForFile(filepath, **kwargs):
    try:
        flags = findFlagsInDatabase(filepath)
    except Exception:
        flags = makeRelativePathsInFlagsAbsolute(defaultFlags,
                                                 directoryOfThisScript())

    return {'flags': flags, 'do_cache': True}
